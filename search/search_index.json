{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Madonna \u00b6 A Python semver parsing library. Free software: MIT License Documentation: https://FollowTheProcess.github.io/madonna/ Project Description \u00b6 Madonna is a small, simple semver utility library with support for parsing, writing, and otherwise interacting with semantic versions in code. Why the stupid name? Get it? \"Like a Version\"... \ud83d\udc4f\ud83c\udffb Also naming things on PyPI is hard! Installation \u00b6 pip install madonna Quickstart \u00b6 The only construct in madonna is the Version object, you can use it for all sorts of useful things... Create a New Version \u00b6 from madonna import Version v = Version ( major = 1 , minor = 2 , patch = 4 ) Parse a Version from a string \u00b6 from madonna import Version Version . from_string ( \"v1.2.4-rc.1+build.123\" ) # Version(major=1, minor=2, patch=4, prerelease=\"rc.1\", buildmetadata=\"build.123\") Or JSON \u00b6 from madonna import Version Version . from_json ( '{\"major\": 1, \"minor\": 2, \"patch\": 4}' ) And you can also dump a Version to a variety of formats too! Contributing \u00b6 madonna is an open source project and, as such, welcomes contributions of all kinds Your best bet is to check out the contributing guide in the docs! Credits \u00b6 This package was created with cookiecutter and the FollowTheProcess/cookie_pypackage project template.","title":"Index"},{"location":"index.html#madonna","text":"A Python semver parsing library. Free software: MIT License Documentation: https://FollowTheProcess.github.io/madonna/","title":"Madonna"},{"location":"index.html#project-description","text":"Madonna is a small, simple semver utility library with support for parsing, writing, and otherwise interacting with semantic versions in code. Why the stupid name? Get it? \"Like a Version\"... \ud83d\udc4f\ud83c\udffb Also naming things on PyPI is hard!","title":"Project Description"},{"location":"index.html#installation","text":"pip install madonna","title":"Installation"},{"location":"index.html#quickstart","text":"The only construct in madonna is the Version object, you can use it for all sorts of useful things...","title":"Quickstart"},{"location":"index.html#create-a-new-version","text":"from madonna import Version v = Version ( major = 1 , minor = 2 , patch = 4 )","title":"Create a New Version"},{"location":"index.html#parse-a-version-from-a-string","text":"from madonna import Version Version . from_string ( \"v1.2.4-rc.1+build.123\" ) # Version(major=1, minor=2, patch=4, prerelease=\"rc.1\", buildmetadata=\"build.123\")","title":"Parse a Version from a string"},{"location":"index.html#or-json","text":"from madonna import Version Version . from_json ( '{\"major\": 1, \"minor\": 2, \"patch\": 4}' ) And you can also dump a Version to a variety of formats too!","title":"Or JSON"},{"location":"index.html#contributing","text":"madonna is an open source project and, as such, welcomes contributions of all kinds Your best bet is to check out the contributing guide in the docs!","title":"Contributing"},{"location":"index.html#credits","text":"This package was created with cookiecutter and the FollowTheProcess/cookie_pypackage project template.","title":"Credits"},{"location":"api/version.html","text":"The Version object \u00b6 Source code in madonna/version.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 class Version : def __init__ ( self , major : int , minor : int , patch : int , prerelease : str | None = None , buildmetadata : str | None = None , ) -> None : \"\"\" A data container for a semantic version. Args: major (int): The major version, to be incremented when making backwards incompatible (breaking) changes. minor (int): The minor version, to be incremented when introducing backwards compatible features. patch (int): The patch version, to be incremented when making backwards compatible bug fixes. prerelease (Optional[str], optional): Any pre-release tags e.g. 'rc.1'. Defaults to None. buildmetadata (Optional[str], optional): Any build meta tags e.g. 'build.123'. Defaults to None. Raises: ValueError: If any numeric version part < 0. \"\"\" self . major = major self . minor = minor self . patch = patch self . prerelease = prerelease self . buildmetadata = buildmetadata if any ( part < 0 for part in ( self . major , self . minor , self . patch )): raise ValueError ( f \"Version { self !r} is invalid. Parts cannot be less than 0.\" ) __slots__ = ( \"major\" , \"minor\" , \"patch\" , \"prerelease\" , \"buildmetadata\" ) def __repr__ ( self ) -> str : return ( self . __class__ . __qualname__ + f \"(major= { self . major !r} , minor= { self . minor !r} , patch= { self . patch !r} , \" + f \"prerelease= { self . prerelease !r} , buildmetadata= { self . buildmetadata !r} )\" ) def __str__ ( self ) -> str : ver = f \"v { self . major } . { self . minor } . { self . patch } \" if self . prerelease : ver += f \"- { self . prerelease } \" if self . buildmetadata : ver += f \"+ { self . buildmetadata } \" return ver def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata , ) == ( other . major , other . minor , other . patch , other . prerelease , other . buildmetadata , ) def __lt__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if ( self . major , self . minor , self . patch ) < ( other . major , other . minor , other . patch , ): return True pre_release_comp = self . _compare_prerelease ( other ) if pre_release_comp == - 1 : return True build_comp = self . _compare_build ( other ) if build_comp == - 1 : return True return False def __gt__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if ( self . major , self . minor , self . patch ) > ( other . major , other . minor , other . patch , ): return True pre_release_comp = self . _compare_prerelease ( other ) if pre_release_comp == 1 : return True build_comp = self . _compare_build ( other ) if build_comp == 1 : return True return False def __le__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if self == other : return True if self < other : return True return False def __ge__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if self == other : return True if self > other : return True return False def __hash__ ( self ) -> int : return hash ( self . to_tuple ()) def _compare_prerelease ( self , other : Version ) -> int : \"\"\" Helper to try and compare the pre-release versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if the numeric version is equal. \"\"\" if self . prerelease == other . prerelease : # The pre release strings are equal return 0 elif self . prerelease and not other . prerelease : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . prerelease and other . prerelease : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . prerelease and other . prerelease : ours = re . findall ( pattern = r \"\\d+\" , string = self . prerelease ) others = re . findall ( pattern = r \"\\d+\" , string = other . prerelease ) if not ours or not others : raise ValueError ( \"Could not parse comparable pre-release version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in pre-release version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . prerelease } and { other . prerelease } \" ) # pragma: no cover def _compare_build ( self , other : Version ) -> int : \"\"\" Helper to try and compare the build metadata versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if both the numeric version and the pre-release strings are equal. \"\"\" if self . buildmetadata == other . buildmetadata : # The pre release strings are equal return 0 elif self . buildmetadata and not other . buildmetadata : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . buildmetadata and other . buildmetadata : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . buildmetadata and other . buildmetadata : ours = re . findall ( pattern = r \"\\d+\" , string = self . buildmetadata ) others = re . findall ( pattern = r \"\\d+\" , string = other . buildmetadata ) if not ours or not others : raise ValueError ( \"Could not parse comparable build metadata version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in build metadata version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . buildmetadata } and { other . buildmetadata } \" ) # pragma: no cover def is_valid ( self ) -> bool : \"\"\" Checks the `Version` against the official semver regex pattern and reports whether or not it is a valid semver. Returns: bool: True if `Version` is valid, else False Examples: ```python >>> v = Version(1, 2, 4) >>> v.is_valid() True ``` ```python >>> v = Version(1, 2, 4, \"blah198y_+-2-\", \"build---19790\") >>> v.is_valid() False ``` \"\"\" return bool ( _SEMVER_REGEX . match ( self . to_string ())) def bump_major ( self ) -> Version : \"\"\" Return a new `Version` with the major version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_major() Version(major=2, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major + 1 , 0 , 0 ) def bump_minor ( self ) -> Version : \"\"\" Return a new `Version` with the minor version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_minor() Version(major=1, minor=3, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor + 1 , 0 ) def bump_patch ( self ) -> Version : \"\"\" Return a new `Version` with the patch version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_patch() Version(major=1, minor=2, patch=5, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor , self . patch + 1 ) def to_string ( self ) -> str : \"\"\" Generate a string representation of the `Version`. Returns: str: Version string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_string() 'v1.2.4' ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_string() 'v1.2.4-rc.2+build.6' ``` \"\"\" return str ( self ) def to_tuple ( self ) -> VersionTuple : \"\"\" Return the `Version` as a tuple of it's fields. Returns: VersionTuple: The Version tuple. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_tuple() (1, 2, 4, None, None) ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_tuple() (1, 2, 4, 'rc.2', 'build.6') ``` \"\"\" return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata ) def to_dict ( self ) -> VersionDict : \"\"\" Return the `Version` as a dictionary. Returns: VersionDict: The Version dictionary. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': None, 'buildmetadata': None} ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': 'rc.1', 'buildmetadata': 'build.2'} ``` \"\"\" return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"buildmetadata\" : self . buildmetadata , } def to_json ( self ) -> str : \"\"\" Return the `Version` as a JSON string. Returns: str: The Version JSON string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' ``` \"\"\" return json . dumps ( self . to_dict ()) @classmethod def from_dict ( cls , version_dict : VersionDict ) -> Version : \"\"\" Construct and return a `Version` from a dictionary of it's parts. Expects a dictionary with keys: `major`, `minor`, `patch`, `prerelease` and `buildmetadata`. Args: version_dict (VersionDict): Version as a dictionary of it's parts. Returns: Version: Constructed Version. Raises: TypeError: If the passed dictionary does not have keys matching the required parts. Examples: ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( ** version_dict ) @classmethod def from_string ( cls , string : str ) -> Version : \"\"\" Construct and return a `Version` from a valid semver string. Args: string (str): The semver string. Raises: ValueError: If the semver string does not pass the official semver regex. Returns: Version: The constructed Version. Examples: ```python >>> Version.from_string(\"v1.2.4\") Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> Version.from_string(\"v1.2.4-rc.1+build.123\") Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" match = _SEMVER_REGEX . match ( string ) if not match : raise ValueError ( f \" { string !r} is not a valid semver string.\" ) return Version . from_dict ( VersionDict ( major = int ( match . group ( \"major\" )), minor = int ( match . group ( \"minor\" )), patch = int ( match . group ( \"patch\" )), prerelease = match . group ( \"prerelease\" ), buildmetadata = match . group ( \"buildmetadata\" ), ) ) @classmethod def from_tuple ( cls , tup : VersionTuple ) -> Version : \"\"\" Construct and return a `Version` from a tuple of it's parts. Args: tup (VersionTuple): The tuple to construct the Version from. Returns: Version: The constructed Version. Examples: ```python >>> v = (1, 2, 4) >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = (1, 2, 4, \"rc.1\", \"build.123\") >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( * tup ) @classmethod def from_json ( cls , json_string : str ) -> Version : \"\"\" Construct and return a `Version` from a json string of it's parts. Args: json_string (str): The json string. Returns: Version: The constructed Version. Examples: ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" data : VersionDict = json . loads ( json_string ) return Version ( ** data ) __init__ ( major , minor , patch , prerelease = None , buildmetadata = None ) \u00b6 A data container for a semantic version. Parameters: Name Type Description Default major int The major version, to be incremented when making backwards incompatible (breaking) changes. required minor int The minor version, to be incremented when introducing backwards compatible features. required patch int The patch version, to be incremented when making backwards compatible bug fixes. required prerelease Optional [ str ] Any pre-release tags e.g. 'rc.1'. Defaults to None. None buildmetadata Optional [ str ] Any build meta tags e.g. 'build.123'. Defaults to None. None Raises: Type Description ValueError If any numeric version part < 0. Source code in madonna/version.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def __init__ ( self , major : int , minor : int , patch : int , prerelease : str | None = None , buildmetadata : str | None = None , ) -> None : \"\"\" A data container for a semantic version. Args: major (int): The major version, to be incremented when making backwards incompatible (breaking) changes. minor (int): The minor version, to be incremented when introducing backwards compatible features. patch (int): The patch version, to be incremented when making backwards compatible bug fixes. prerelease (Optional[str], optional): Any pre-release tags e.g. 'rc.1'. Defaults to None. buildmetadata (Optional[str], optional): Any build meta tags e.g. 'build.123'. Defaults to None. Raises: ValueError: If any numeric version part < 0. \"\"\" self . major = major self . minor = minor self . patch = patch self . prerelease = prerelease self . buildmetadata = buildmetadata if any ( part < 0 for part in ( self . major , self . minor , self . patch )): raise ValueError ( f \"Version { self !r} is invalid. Parts cannot be less than 0.\" ) _compare_build ( other ) \u00b6 Helper to try and compare the build metadata versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if both the numeric version and the pre-release strings are equal. Source code in madonna/version.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def _compare_build ( self , other : Version ) -> int : \"\"\" Helper to try and compare the build metadata versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if both the numeric version and the pre-release strings are equal. \"\"\" if self . buildmetadata == other . buildmetadata : # The pre release strings are equal return 0 elif self . buildmetadata and not other . buildmetadata : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . buildmetadata and other . buildmetadata : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . buildmetadata and other . buildmetadata : ours = re . findall ( pattern = r \"\\d+\" , string = self . buildmetadata ) others = re . findall ( pattern = r \"\\d+\" , string = other . buildmetadata ) if not ours or not others : raise ValueError ( \"Could not parse comparable build metadata version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in build metadata version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . buildmetadata } and { other . buildmetadata } \" ) # pragma: no cover _compare_prerelease ( other ) \u00b6 Helper to try and compare the pre-release versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if the numeric version is equal. Source code in madonna/version.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def _compare_prerelease ( self , other : Version ) -> int : \"\"\" Helper to try and compare the pre-release versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if the numeric version is equal. \"\"\" if self . prerelease == other . prerelease : # The pre release strings are equal return 0 elif self . prerelease and not other . prerelease : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . prerelease and other . prerelease : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . prerelease and other . prerelease : ours = re . findall ( pattern = r \"\\d+\" , string = self . prerelease ) others = re . findall ( pattern = r \"\\d+\" , string = other . prerelease ) if not ours or not others : raise ValueError ( \"Could not parse comparable pre-release version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in pre-release version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . prerelease } and { other . prerelease } \" ) # pragma: no cover bump_major () \u00b6 Return a new Version with the major version number bumped. Returns: Name Type Description Version Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_major () Version ( major = 2 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def bump_major ( self ) -> Version : \"\"\" Return a new `Version` with the major version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_major() Version(major=2, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major + 1 , 0 , 0 ) bump_minor () \u00b6 Return a new Version with the minor version number bumped. Returns: Name Type Description Version Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_minor () Version ( major = 1 , minor = 3 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def bump_minor ( self ) -> Version : \"\"\" Return a new `Version` with the minor version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_minor() Version(major=1, minor=3, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor + 1 , 0 ) bump_patch () \u00b6 Return a new Version with the patch version number bumped. Returns: Name Type Description Version Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_patch () Version ( major = 1 , minor = 2 , patch = 5 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def bump_patch ( self ) -> Version : \"\"\" Return a new `Version` with the patch version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_patch() Version(major=1, minor=2, patch=5, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor , self . patch + 1 ) from_dict ( version_dict ) classmethod \u00b6 Construct and return a Version from a dictionary of it's parts. Expects a dictionary with keys: major , minor , patch , prerelease and buildmetadata . Parameters: Name Type Description Default version_dict VersionDict Version as a dictionary of it's parts. required Returns: Name Type Description Version Version Constructed Version. Raises: Type Description TypeError If the passed dictionary does not have keys matching the required parts. Examples: >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 , \"prerelease\" : \"rc.1\" , \"buildmetadata\" : \"build.123\" } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 @classmethod def from_dict ( cls , version_dict : VersionDict ) -> Version : \"\"\" Construct and return a `Version` from a dictionary of it's parts. Expects a dictionary with keys: `major`, `minor`, `patch`, `prerelease` and `buildmetadata`. Args: version_dict (VersionDict): Version as a dictionary of it's parts. Returns: Version: Constructed Version. Raises: TypeError: If the passed dictionary does not have keys matching the required parts. Examples: ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( ** version_dict ) from_json ( json_string ) classmethod \u00b6 Construct and return a Version from a json string of it's parts. Parameters: Name Type Description Default json_string str The json string. required Returns: Name Type Description Version Version The constructed Version. Examples: >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 @classmethod def from_json ( cls , json_string : str ) -> Version : \"\"\" Construct and return a `Version` from a json string of it's parts. Args: json_string (str): The json string. Returns: Version: The constructed Version. Examples: ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" data : VersionDict = json . loads ( json_string ) return Version ( ** data ) from_string ( string ) classmethod \u00b6 Construct and return a Version from a valid semver string. Parameters: Name Type Description Default string str The semver string. required Raises: Type Description ValueError If the semver string does not pass the official semver regex. Returns: Name Type Description Version Version The constructed Version. Examples: >>> Version . from_string ( \"v1.2.4\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> Version . from_string ( \"v1.2.4-rc.1+build.123\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 @classmethod def from_string ( cls , string : str ) -> Version : \"\"\" Construct and return a `Version` from a valid semver string. Args: string (str): The semver string. Raises: ValueError: If the semver string does not pass the official semver regex. Returns: Version: The constructed Version. Examples: ```python >>> Version.from_string(\"v1.2.4\") Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> Version.from_string(\"v1.2.4-rc.1+build.123\") Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" match = _SEMVER_REGEX . match ( string ) if not match : raise ValueError ( f \" { string !r} is not a valid semver string.\" ) return Version . from_dict ( VersionDict ( major = int ( match . group ( \"major\" )), minor = int ( match . group ( \"minor\" )), patch = int ( match . group ( \"patch\" )), prerelease = match . group ( \"prerelease\" ), buildmetadata = match . group ( \"buildmetadata\" ), ) ) from_tuple ( tup ) classmethod \u00b6 Construct and return a Version from a tuple of it's parts. Parameters: Name Type Description Default tup VersionTuple The tuple to construct the Version from. required Returns: Name Type Description Version Version The constructed Version. Examples: >>> v = ( 1 , 2 , 4 ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = ( 1 , 2 , 4 , \"rc.1\" , \"build.123\" ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 @classmethod def from_tuple ( cls , tup : VersionTuple ) -> Version : \"\"\" Construct and return a `Version` from a tuple of it's parts. Args: tup (VersionTuple): The tuple to construct the Version from. Returns: Version: The constructed Version. Examples: ```python >>> v = (1, 2, 4) >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = (1, 2, 4, \"rc.1\", \"build.123\") >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( * tup ) is_valid () \u00b6 Checks the Version against the official semver regex pattern and reports whether or not it is a valid semver. Returns: Name Type Description bool bool True if Version is valid, else False Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . is_valid () True >>> v = Version ( 1 , 2 , 4 , \"blah198y_+-2-\" , \"build---19790\" ) >>> v . is_valid () False Source code in madonna/version.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def is_valid ( self ) -> bool : \"\"\" Checks the `Version` against the official semver regex pattern and reports whether or not it is a valid semver. Returns: bool: True if `Version` is valid, else False Examples: ```python >>> v = Version(1, 2, 4) >>> v.is_valid() True ``` ```python >>> v = Version(1, 2, 4, \"blah198y_+-2-\", \"build---19790\") >>> v.is_valid() False ``` \"\"\" return bool ( _SEMVER_REGEX . match ( self . to_string ())) to_dict () \u00b6 Return the Version as a dictionary. Returns: Name Type Description VersionDict VersionDict The Version dictionary. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : None , 'buildmetadata' : None } >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : 'rc.1' , 'buildmetadata' : 'build.2' } Source code in madonna/version.py 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 def to_dict ( self ) -> VersionDict : \"\"\" Return the `Version` as a dictionary. Returns: VersionDict: The Version dictionary. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': None, 'buildmetadata': None} ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': 'rc.1', 'buildmetadata': 'build.2'} ``` \"\"\" return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"buildmetadata\" : self . buildmetadata , } to_json () \u00b6 Return the Version as a JSON string. Returns: Name Type Description str str The Version JSON string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' Source code in madonna/version.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def to_json ( self ) -> str : \"\"\" Return the `Version` as a JSON string. Returns: str: The Version JSON string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' ``` \"\"\" return json . dumps ( self . to_dict ()) to_string () \u00b6 Generate a string representation of the Version . Returns: Name Type Description str str Version string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_string () 'v1.2.4' >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_string () 'v1.2.4-rc.2+build.6' Source code in madonna/version.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def to_string ( self ) -> str : \"\"\" Generate a string representation of the `Version`. Returns: str: Version string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_string() 'v1.2.4' ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_string() 'v1.2.4-rc.2+build.6' ``` \"\"\" return str ( self ) to_tuple () \u00b6 Return the Version as a tuple of it's fields. Returns: Name Type Description VersionTuple VersionTuple The Version tuple. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_tuple () ( 1 , 2 , 4 , None , None ) >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_tuple () ( 1 , 2 , 4 , 'rc.2' , 'build.6' ) Source code in madonna/version.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def to_tuple ( self ) -> VersionTuple : \"\"\" Return the `Version` as a tuple of it's fields. Returns: VersionTuple: The Version tuple. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_tuple() (1, 2, 4, None, None) ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_tuple() (1, 2, 4, 'rc.2', 'build.6') ``` \"\"\" return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata )","title":"Version"},{"location":"api/version.html#the-version-object","text":"Source code in madonna/version.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 class Version : def __init__ ( self , major : int , minor : int , patch : int , prerelease : str | None = None , buildmetadata : str | None = None , ) -> None : \"\"\" A data container for a semantic version. Args: major (int): The major version, to be incremented when making backwards incompatible (breaking) changes. minor (int): The minor version, to be incremented when introducing backwards compatible features. patch (int): The patch version, to be incremented when making backwards compatible bug fixes. prerelease (Optional[str], optional): Any pre-release tags e.g. 'rc.1'. Defaults to None. buildmetadata (Optional[str], optional): Any build meta tags e.g. 'build.123'. Defaults to None. Raises: ValueError: If any numeric version part < 0. \"\"\" self . major = major self . minor = minor self . patch = patch self . prerelease = prerelease self . buildmetadata = buildmetadata if any ( part < 0 for part in ( self . major , self . minor , self . patch )): raise ValueError ( f \"Version { self !r} is invalid. Parts cannot be less than 0.\" ) __slots__ = ( \"major\" , \"minor\" , \"patch\" , \"prerelease\" , \"buildmetadata\" ) def __repr__ ( self ) -> str : return ( self . __class__ . __qualname__ + f \"(major= { self . major !r} , minor= { self . minor !r} , patch= { self . patch !r} , \" + f \"prerelease= { self . prerelease !r} , buildmetadata= { self . buildmetadata !r} )\" ) def __str__ ( self ) -> str : ver = f \"v { self . major } . { self . minor } . { self . patch } \" if self . prerelease : ver += f \"- { self . prerelease } \" if self . buildmetadata : ver += f \"+ { self . buildmetadata } \" return ver def __eq__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata , ) == ( other . major , other . minor , other . patch , other . prerelease , other . buildmetadata , ) def __lt__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if ( self . major , self . minor , self . patch ) < ( other . major , other . minor , other . patch , ): return True pre_release_comp = self . _compare_prerelease ( other ) if pre_release_comp == - 1 : return True build_comp = self . _compare_build ( other ) if build_comp == - 1 : return True return False def __gt__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if ( self . major , self . minor , self . patch ) > ( other . major , other . minor , other . patch , ): return True pre_release_comp = self . _compare_prerelease ( other ) if pre_release_comp == 1 : return True build_comp = self . _compare_build ( other ) if build_comp == 1 : return True return False def __le__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if self == other : return True if self < other : return True return False def __ge__ ( self , other : object ) -> bool : if not isinstance ( other , Version ): raise TypeError ( f \"Cannot compare object of type Version and { type ( other ) } \" ) if self == other : return True if self > other : return True return False def __hash__ ( self ) -> int : return hash ( self . to_tuple ()) def _compare_prerelease ( self , other : Version ) -> int : \"\"\" Helper to try and compare the pre-release versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if the numeric version is equal. \"\"\" if self . prerelease == other . prerelease : # The pre release strings are equal return 0 elif self . prerelease and not other . prerelease : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . prerelease and other . prerelease : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . prerelease and other . prerelease : ours = re . findall ( pattern = r \"\\d+\" , string = self . prerelease ) others = re . findall ( pattern = r \"\\d+\" , string = other . prerelease ) if not ours or not others : raise ValueError ( \"Could not parse comparable pre-release version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in pre-release version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . prerelease } and { other . prerelease } \" ) # pragma: no cover def _compare_build ( self , other : Version ) -> int : \"\"\" Helper to try and compare the build metadata versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if both the numeric version and the pre-release strings are equal. \"\"\" if self . buildmetadata == other . buildmetadata : # The pre release strings are equal return 0 elif self . buildmetadata and not other . buildmetadata : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . buildmetadata and other . buildmetadata : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . buildmetadata and other . buildmetadata : ours = re . findall ( pattern = r \"\\d+\" , string = self . buildmetadata ) others = re . findall ( pattern = r \"\\d+\" , string = other . buildmetadata ) if not ours or not others : raise ValueError ( \"Could not parse comparable build metadata version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in build metadata version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . buildmetadata } and { other . buildmetadata } \" ) # pragma: no cover def is_valid ( self ) -> bool : \"\"\" Checks the `Version` against the official semver regex pattern and reports whether or not it is a valid semver. Returns: bool: True if `Version` is valid, else False Examples: ```python >>> v = Version(1, 2, 4) >>> v.is_valid() True ``` ```python >>> v = Version(1, 2, 4, \"blah198y_+-2-\", \"build---19790\") >>> v.is_valid() False ``` \"\"\" return bool ( _SEMVER_REGEX . match ( self . to_string ())) def bump_major ( self ) -> Version : \"\"\" Return a new `Version` with the major version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_major() Version(major=2, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major + 1 , 0 , 0 ) def bump_minor ( self ) -> Version : \"\"\" Return a new `Version` with the minor version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_minor() Version(major=1, minor=3, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor + 1 , 0 ) def bump_patch ( self ) -> Version : \"\"\" Return a new `Version` with the patch version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_patch() Version(major=1, minor=2, patch=5, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor , self . patch + 1 ) def to_string ( self ) -> str : \"\"\" Generate a string representation of the `Version`. Returns: str: Version string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_string() 'v1.2.4' ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_string() 'v1.2.4-rc.2+build.6' ``` \"\"\" return str ( self ) def to_tuple ( self ) -> VersionTuple : \"\"\" Return the `Version` as a tuple of it's fields. Returns: VersionTuple: The Version tuple. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_tuple() (1, 2, 4, None, None) ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_tuple() (1, 2, 4, 'rc.2', 'build.6') ``` \"\"\" return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata ) def to_dict ( self ) -> VersionDict : \"\"\" Return the `Version` as a dictionary. Returns: VersionDict: The Version dictionary. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': None, 'buildmetadata': None} ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': 'rc.1', 'buildmetadata': 'build.2'} ``` \"\"\" return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"buildmetadata\" : self . buildmetadata , } def to_json ( self ) -> str : \"\"\" Return the `Version` as a JSON string. Returns: str: The Version JSON string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' ``` \"\"\" return json . dumps ( self . to_dict ()) @classmethod def from_dict ( cls , version_dict : VersionDict ) -> Version : \"\"\" Construct and return a `Version` from a dictionary of it's parts. Expects a dictionary with keys: `major`, `minor`, `patch`, `prerelease` and `buildmetadata`. Args: version_dict (VersionDict): Version as a dictionary of it's parts. Returns: Version: Constructed Version. Raises: TypeError: If the passed dictionary does not have keys matching the required parts. Examples: ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( ** version_dict ) @classmethod def from_string ( cls , string : str ) -> Version : \"\"\" Construct and return a `Version` from a valid semver string. Args: string (str): The semver string. Raises: ValueError: If the semver string does not pass the official semver regex. Returns: Version: The constructed Version. Examples: ```python >>> Version.from_string(\"v1.2.4\") Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> Version.from_string(\"v1.2.4-rc.1+build.123\") Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" match = _SEMVER_REGEX . match ( string ) if not match : raise ValueError ( f \" { string !r} is not a valid semver string.\" ) return Version . from_dict ( VersionDict ( major = int ( match . group ( \"major\" )), minor = int ( match . group ( \"minor\" )), patch = int ( match . group ( \"patch\" )), prerelease = match . group ( \"prerelease\" ), buildmetadata = match . group ( \"buildmetadata\" ), ) ) @classmethod def from_tuple ( cls , tup : VersionTuple ) -> Version : \"\"\" Construct and return a `Version` from a tuple of it's parts. Args: tup (VersionTuple): The tuple to construct the Version from. Returns: Version: The constructed Version. Examples: ```python >>> v = (1, 2, 4) >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = (1, 2, 4, \"rc.1\", \"build.123\") >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( * tup ) @classmethod def from_json ( cls , json_string : str ) -> Version : \"\"\" Construct and return a `Version` from a json string of it's parts. Args: json_string (str): The json string. Returns: Version: The constructed Version. Examples: ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" data : VersionDict = json . loads ( json_string ) return Version ( ** data )","title":"The Version object"},{"location":"api/version.html#madonna.version.Version.__init__","text":"A data container for a semantic version. Parameters: Name Type Description Default major int The major version, to be incremented when making backwards incompatible (breaking) changes. required minor int The minor version, to be incremented when introducing backwards compatible features. required patch int The patch version, to be incremented when making backwards compatible bug fixes. required prerelease Optional [ str ] Any pre-release tags e.g. 'rc.1'. Defaults to None. None buildmetadata Optional [ str ] Any build meta tags e.g. 'build.123'. Defaults to None. None Raises: Type Description ValueError If any numeric version part < 0. Source code in madonna/version.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def __init__ ( self , major : int , minor : int , patch : int , prerelease : str | None = None , buildmetadata : str | None = None , ) -> None : \"\"\" A data container for a semantic version. Args: major (int): The major version, to be incremented when making backwards incompatible (breaking) changes. minor (int): The minor version, to be incremented when introducing backwards compatible features. patch (int): The patch version, to be incremented when making backwards compatible bug fixes. prerelease (Optional[str], optional): Any pre-release tags e.g. 'rc.1'. Defaults to None. buildmetadata (Optional[str], optional): Any build meta tags e.g. 'build.123'. Defaults to None. Raises: ValueError: If any numeric version part < 0. \"\"\" self . major = major self . minor = minor self . patch = patch self . prerelease = prerelease self . buildmetadata = buildmetadata if any ( part < 0 for part in ( self . major , self . minor , self . patch )): raise ValueError ( f \"Version { self !r} is invalid. Parts cannot be less than 0.\" )","title":"__init__()"},{"location":"api/version.html#madonna.version.Version._compare_build","text":"Helper to try and compare the build metadata versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if both the numeric version and the pre-release strings are equal. Source code in madonna/version.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 def _compare_build ( self , other : Version ) -> int : \"\"\" Helper to try and compare the build metadata versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if both the numeric version and the pre-release strings are equal. \"\"\" if self . buildmetadata == other . buildmetadata : # The pre release strings are equal return 0 elif self . buildmetadata and not other . buildmetadata : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . buildmetadata and other . buildmetadata : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . buildmetadata and other . buildmetadata : ours = re . findall ( pattern = r \"\\d+\" , string = self . buildmetadata ) others = re . findall ( pattern = r \"\\d+\" , string = other . buildmetadata ) if not ours or not others : raise ValueError ( \"Could not parse comparable build metadata version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in build metadata version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . buildmetadata } and { other . buildmetadata } \" ) # pragma: no cover","title":"_compare_build()"},{"location":"api/version.html#madonna.version.Version._compare_prerelease","text":"Helper to try and compare the pre-release versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if the numeric version is equal. Source code in madonna/version.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def _compare_prerelease ( self , other : Version ) -> int : \"\"\" Helper to try and compare the pre-release versions. It will check for string equality, whether or not the different versions have pre-releases, check for integers in the text and compare based on them, and if none of this works will raise a ValueError. Note: This is only called if the numeric version is equal. \"\"\" if self . prerelease == other . prerelease : # The pre release strings are equal return 0 elif self . prerelease and not other . prerelease : # Ours has a pre-release but the other doesn't # meaning ours is less return - 1 elif not self . prerelease and other . prerelease : # Ours doesn't have a pre-release but the other # does meaning ours is greater return 1 # Try and extract a number to compare if self . prerelease and other . prerelease : ours = re . findall ( pattern = r \"\\d+\" , string = self . prerelease ) others = re . findall ( pattern = r \"\\d+\" , string = other . prerelease ) if not ours or not others : raise ValueError ( \"Could not parse comparable pre-release version info.\" ) if len ( ours ) > 1 or len ( others ) > 1 : raise ValueError ( \"Multiple integers found in pre-release version.\" ) our_version = int ( ours . pop ()) other_version = int ( others . pop ()) if our_version == other_version : return 0 elif our_version > other_version : return 1 elif our_version < other_version : return - 1 # If we get here, we couldn't parse the pre-release raise ValueError ( f \"Could not compare { self . prerelease } and { other . prerelease } \" ) # pragma: no cover","title":"_compare_prerelease()"},{"location":"api/version.html#madonna.version.Version.bump_major","text":"Return a new Version with the major version number bumped. Returns: Name Type Description Version Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_major () Version ( major = 2 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 def bump_major ( self ) -> Version : \"\"\" Return a new `Version` with the major version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_major() Version(major=2, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major + 1 , 0 , 0 )","title":"bump_major()"},{"location":"api/version.html#madonna.version.Version.bump_minor","text":"Return a new Version with the minor version number bumped. Returns: Name Type Description Version Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_minor () Version ( major = 1 , minor = 3 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def bump_minor ( self ) -> Version : \"\"\" Return a new `Version` with the minor version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_minor() Version(major=1, minor=3, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor + 1 , 0 )","title":"bump_minor()"},{"location":"api/version.html#madonna.version.Version.bump_patch","text":"Return a new Version with the patch version number bumped. Returns: Name Type Description Version Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_patch () Version ( major = 1 , minor = 2 , patch = 5 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 def bump_patch ( self ) -> Version : \"\"\" Return a new `Version` with the patch version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_patch() Version(major=1, minor=2, patch=5, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor , self . patch + 1 )","title":"bump_patch()"},{"location":"api/version.html#madonna.version.Version.from_dict","text":"Construct and return a Version from a dictionary of it's parts. Expects a dictionary with keys: major , minor , patch , prerelease and buildmetadata . Parameters: Name Type Description Default version_dict VersionDict Version as a dictionary of it's parts. required Returns: Name Type Description Version Version Constructed Version. Raises: Type Description TypeError If the passed dictionary does not have keys matching the required parts. Examples: >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 , \"prerelease\" : \"rc.1\" , \"buildmetadata\" : \"build.123\" } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 @classmethod def from_dict ( cls , version_dict : VersionDict ) -> Version : \"\"\" Construct and return a `Version` from a dictionary of it's parts. Expects a dictionary with keys: `major`, `minor`, `patch`, `prerelease` and `buildmetadata`. Args: version_dict (VersionDict): Version as a dictionary of it's parts. Returns: Version: Constructed Version. Raises: TypeError: If the passed dictionary does not have keys matching the required parts. Examples: ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( ** version_dict )","title":"from_dict()"},{"location":"api/version.html#madonna.version.Version.from_json","text":"Construct and return a Version from a json string of it's parts. Parameters: Name Type Description Default json_string str The json string. required Returns: Name Type Description Version Version The constructed Version. Examples: >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 @classmethod def from_json ( cls , json_string : str ) -> Version : \"\"\" Construct and return a `Version` from a json string of it's parts. Args: json_string (str): The json string. Returns: Version: The constructed Version. Examples: ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" data : VersionDict = json . loads ( json_string ) return Version ( ** data )","title":"from_json()"},{"location":"api/version.html#madonna.version.Version.from_string","text":"Construct and return a Version from a valid semver string. Parameters: Name Type Description Default string str The semver string. required Raises: Type Description ValueError If the semver string does not pass the official semver regex. Returns: Name Type Description Version Version The constructed Version. Examples: >>> Version . from_string ( \"v1.2.4\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> Version . from_string ( \"v1.2.4-rc.1+build.123\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 @classmethod def from_string ( cls , string : str ) -> Version : \"\"\" Construct and return a `Version` from a valid semver string. Args: string (str): The semver string. Raises: ValueError: If the semver string does not pass the official semver regex. Returns: Version: The constructed Version. Examples: ```python >>> Version.from_string(\"v1.2.4\") Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> Version.from_string(\"v1.2.4-rc.1+build.123\") Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" match = _SEMVER_REGEX . match ( string ) if not match : raise ValueError ( f \" { string !r} is not a valid semver string.\" ) return Version . from_dict ( VersionDict ( major = int ( match . group ( \"major\" )), minor = int ( match . group ( \"minor\" )), patch = int ( match . group ( \"patch\" )), prerelease = match . group ( \"prerelease\" ), buildmetadata = match . group ( \"buildmetadata\" ), ) )","title":"from_string()"},{"location":"api/version.html#madonna.version.Version.from_tuple","text":"Construct and return a Version from a tuple of it's parts. Parameters: Name Type Description Default tup VersionTuple The tuple to construct the Version from. required Returns: Name Type Description Version Version The constructed Version. Examples: >>> v = ( 1 , 2 , 4 ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = ( 1 , 2 , 4 , \"rc.1\" , \"build.123\" ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 @classmethod def from_tuple ( cls , tup : VersionTuple ) -> Version : \"\"\" Construct and return a `Version` from a tuple of it's parts. Args: tup (VersionTuple): The tuple to construct the Version from. Returns: Version: The constructed Version. Examples: ```python >>> v = (1, 2, 4) >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = (1, 2, 4, \"rc.1\", \"build.123\") >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( * tup )","title":"from_tuple()"},{"location":"api/version.html#madonna.version.Version.is_valid","text":"Checks the Version against the official semver regex pattern and reports whether or not it is a valid semver. Returns: Name Type Description bool bool True if Version is valid, else False Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . is_valid () True >>> v = Version ( 1 , 2 , 4 , \"blah198y_+-2-\" , \"build---19790\" ) >>> v . is_valid () False Source code in madonna/version.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 def is_valid ( self ) -> bool : \"\"\" Checks the `Version` against the official semver regex pattern and reports whether or not it is a valid semver. Returns: bool: True if `Version` is valid, else False Examples: ```python >>> v = Version(1, 2, 4) >>> v.is_valid() True ``` ```python >>> v = Version(1, 2, 4, \"blah198y_+-2-\", \"build---19790\") >>> v.is_valid() False ``` \"\"\" return bool ( _SEMVER_REGEX . match ( self . to_string ()))","title":"is_valid()"},{"location":"api/version.html#madonna.version.Version.to_dict","text":"Return the Version as a dictionary. Returns: Name Type Description VersionDict VersionDict The Version dictionary. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : None , 'buildmetadata' : None } >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : 'rc.1' , 'buildmetadata' : 'build.2' } Source code in madonna/version.py 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 def to_dict ( self ) -> VersionDict : \"\"\" Return the `Version` as a dictionary. Returns: VersionDict: The Version dictionary. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': None, 'buildmetadata': None} ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': 'rc.1', 'buildmetadata': 'build.2'} ``` \"\"\" return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"buildmetadata\" : self . buildmetadata , }","title":"to_dict()"},{"location":"api/version.html#madonna.version.Version.to_json","text":"Return the Version as a JSON string. Returns: Name Type Description str str The Version JSON string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' Source code in madonna/version.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def to_json ( self ) -> str : \"\"\" Return the `Version` as a JSON string. Returns: str: The Version JSON string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' ``` \"\"\" return json . dumps ( self . to_dict ())","title":"to_json()"},{"location":"api/version.html#madonna.version.Version.to_string","text":"Generate a string representation of the Version . Returns: Name Type Description str str Version string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_string () 'v1.2.4' >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_string () 'v1.2.4-rc.2+build.6' Source code in madonna/version.py 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def to_string ( self ) -> str : \"\"\" Generate a string representation of the `Version`. Returns: str: Version string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_string() 'v1.2.4' ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_string() 'v1.2.4-rc.2+build.6' ``` \"\"\" return str ( self )","title":"to_string()"},{"location":"api/version.html#madonna.version.Version.to_tuple","text":"Return the Version as a tuple of it's fields. Returns: Name Type Description VersionTuple VersionTuple The Version tuple. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_tuple () ( 1 , 2 , 4 , None , None ) >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_tuple () ( 1 , 2 , 4 , 'rc.2' , 'build.6' ) Source code in madonna/version.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 def to_tuple ( self ) -> VersionTuple : \"\"\" Return the `Version` as a tuple of it's fields. Returns: VersionTuple: The Version tuple. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_tuple() (1, 2, 4, None, None) ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_tuple() (1, 2, 4, 'rc.2', 'build.6') ``` \"\"\" return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata )","title":"to_tuple()"},{"location":"contributing/code_of_conduct.html","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"contributing/code_of_conduct.html#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"contributing/code_of_conduct.html#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"contributing/code_of_conduct.html#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"contributing/code_of_conduct.html#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"contributing/code_of_conduct.html#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"contributing/code_of_conduct.html#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"contributing/code_of_conduct.html#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"contributing/contributing.html","text":"Contributing to madonna \u00b6 I've tried to structure madonna to make it nice and easy for people to contribute. Here's how to go about doing it! Note All contributors must follow the Code of Conduct Developing \u00b6 If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to madonna: here's how you do it! To work on madonna you'll need python >=3.8 Step 1: Fork madonna \u00b6 The first thing to do is 'fork' madonna. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of madonna still works! To create a fork, go to the madonna repo and click on the fork button! Step 2: Clone your fork \u00b6 Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/madonna.git If you use SSH: git clone git@github.com:<your_github_username>/madonna.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/madonna HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd madonna This will take you into the root directory of the project. Now add the original madonna repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/madonna.git This makes the original version of madonna upstream but not origin . Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Note Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower! Step 3: Create the Environment \u00b6 Before you do anything, you'll want to set up your development environment... madonna uses poetry to manage development and nox for automation superpowers. So to work on it you'll need to get both of those tools too! I recommend using pipx for python command line tools like these, it installs each tool in it's own isolated environment but exposes the command to your terminal as if you installed it globally. We've automated the crap out of the development process for madonna, to get started all you need to do is run: nox Note If you've never used nox before, go check it out. It's great! It's an amazing project automation toolkit, you can do just about anything with it but it's especially good at things like this! When you run this, nox will: Create a fresh python virtual environment in the project for you (.venv) Install madonna for you along with all of it's development dependencies Make sure VSCode is set up to use this environment (if you use it) Not bad for a single command! Doing it this way means that before you start working on madonna you know its all been installed and works correctly. Wait for it to do it's thing and then you can get started. Note The next time you run nox , it won't do this step again. It will run all the project tests, lint and format the source code, analyse test coverage and build the docs Step 4: Do your thing \u00b6 Always checkout a new branch before changing anything git checkout -b <name-of-your-bugfix-or-feature> Now you're ready to start working! Remember! madonna aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! madonna uses nox for automated testing, building the docs, formatting and linting etc. So when you've made your changes, just run: nox And it will tell you if something's wrong! Step 5: Commit your changes \u00b6 Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name> Step 6: Create a Pull Request \u00b6 Now go to the original madonna repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. That's it! Your code will be tested automatically by madonna's CI suite and if everything passes and your PR is approved and merged then it will become part of madonna! Note: There is a good guide to open source contribution workflow here and also here too Contributing to Docs \u00b6 Any improvements to the documentation are always appreciated! madonna uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Because madonna uses nox , things like building and serving the documentation is super easy. All you have to do is: # Builds the docs nox -s docs # Builds and serves to localhost nox -s docs -- serve If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Guide"},{"location":"contributing/contributing.html#contributing-to-madonna","text":"I've tried to structure madonna to make it nice and easy for people to contribute. Here's how to go about doing it! Note All contributors must follow the Code of Conduct","title":"Contributing to madonna"},{"location":"contributing/contributing.html#developing","text":"If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to madonna: here's how you do it! To work on madonna you'll need python >=3.8","title":"Developing"},{"location":"contributing/contributing.html#step-1-fork-madonna","text":"The first thing to do is 'fork' madonna. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of madonna still works! To create a fork, go to the madonna repo and click on the fork button!","title":"Step 1: Fork madonna"},{"location":"contributing/contributing.html#step-2-clone-your-fork","text":"Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/madonna.git If you use SSH: git clone git@github.com:<your_github_username>/madonna.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/madonna HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd madonna This will take you into the root directory of the project. Now add the original madonna repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/madonna.git This makes the original version of madonna upstream but not origin . Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Note Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower!","title":"Step 2: Clone your fork"},{"location":"contributing/contributing.html#step-3-create-the-environment","text":"Before you do anything, you'll want to set up your development environment... madonna uses poetry to manage development and nox for automation superpowers. So to work on it you'll need to get both of those tools too! I recommend using pipx for python command line tools like these, it installs each tool in it's own isolated environment but exposes the command to your terminal as if you installed it globally. We've automated the crap out of the development process for madonna, to get started all you need to do is run: nox Note If you've never used nox before, go check it out. It's great! It's an amazing project automation toolkit, you can do just about anything with it but it's especially good at things like this! When you run this, nox will: Create a fresh python virtual environment in the project for you (.venv) Install madonna for you along with all of it's development dependencies Make sure VSCode is set up to use this environment (if you use it) Not bad for a single command! Doing it this way means that before you start working on madonna you know its all been installed and works correctly. Wait for it to do it's thing and then you can get started. Note The next time you run nox , it won't do this step again. It will run all the project tests, lint and format the source code, analyse test coverage and build the docs","title":"Step 3: Create the Environment"},{"location":"contributing/contributing.html#step-4-do-your-thing","text":"Always checkout a new branch before changing anything git checkout -b <name-of-your-bugfix-or-feature> Now you're ready to start working! Remember! madonna aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! madonna uses nox for automated testing, building the docs, formatting and linting etc. So when you've made your changes, just run: nox And it will tell you if something's wrong!","title":"Step 4: Do your thing"},{"location":"contributing/contributing.html#step-5-commit-your-changes","text":"Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name>","title":"Step 5: Commit your changes"},{"location":"contributing/contributing.html#step-6-create-a-pull-request","text":"Now go to the original madonna repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. That's it! Your code will be tested automatically by madonna's CI suite and if everything passes and your PR is approved and merged then it will become part of madonna! Note: There is a good guide to open source contribution workflow here and also here too","title":"Step 6: Create a Pull Request"},{"location":"contributing/contributing.html#contributing-to-docs","text":"Any improvements to the documentation are always appreciated! madonna uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Because madonna uses nox , things like building and serving the documentation is super easy. All you have to do is: # Builds the docs nox -s docs # Builds and serves to localhost nox -s docs -- serve If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Contributing to Docs"}]}