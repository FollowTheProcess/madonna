{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Madonna \u00b6 A Python semver parsing library. Free software: MIT License Documentation: https://FollowTheProcess.github.io/madonna/ Project Description \u00b6 Madonna is a small, simple semver utility library with support for parsing, writing, and otherwise interacting with semantic versions in code. Why the stupid name? Get it? \"Like a Version\"... \ud83d\udc4f\ud83c\udffb Also naming things on PyPI is hard! Installation \u00b6 pip install madonna Quickstart \u00b6 The only construct in madonna is the Version object, you can use it for all sorts of useful things... Create a New Version \u00b6 from madonna import Version v = Version ( major = 1 , minor = 2 , patch = 4 ) Parse a Version from a string \u00b6 from madonna import Version Version . from_string ( \"v1.2.4-rc.1+build.123\" ) # Version(major=1, minor=2, patch=4, prerelease=\"rc.1\", buildmetadata=\"build.123\") Or JSON \u00b6 from madonna import Version Version . from_json ( '{\"major\": 1, \"minor\": 2, \"patch\": 4}' ) And you can also dump a Version to a variety of formats too! Contributing \u00b6 madonna is an open source project and, as such, welcomes contributions of all kinds Your best bet is to check out the contributing guide in the docs! Credits \u00b6 This package was created with cookiecutter and the FollowTheProcess/cookie_pypackage project template.","title":"Index"},{"location":"index.html#madonna","text":"A Python semver parsing library. Free software: MIT License Documentation: https://FollowTheProcess.github.io/madonna/","title":"Madonna"},{"location":"index.html#project-description","text":"Madonna is a small, simple semver utility library with support for parsing, writing, and otherwise interacting with semantic versions in code. Why the stupid name? Get it? \"Like a Version\"... \ud83d\udc4f\ud83c\udffb Also naming things on PyPI is hard!","title":"Project Description"},{"location":"index.html#installation","text":"pip install madonna","title":"Installation"},{"location":"index.html#quickstart","text":"The only construct in madonna is the Version object, you can use it for all sorts of useful things...","title":"Quickstart"},{"location":"index.html#create-a-new-version","text":"from madonna import Version v = Version ( major = 1 , minor = 2 , patch = 4 )","title":"Create a New Version"},{"location":"index.html#parse-a-version-from-a-string","text":"from madonna import Version Version . from_string ( \"v1.2.4-rc.1+build.123\" ) # Version(major=1, minor=2, patch=4, prerelease=\"rc.1\", buildmetadata=\"build.123\")","title":"Parse a Version from a string"},{"location":"index.html#or-json","text":"from madonna import Version Version . from_json ( '{\"major\": 1, \"minor\": 2, \"patch\": 4}' ) And you can also dump a Version to a variety of formats too!","title":"Or JSON"},{"location":"index.html#contributing","text":"madonna is an open source project and, as such, welcomes contributions of all kinds Your best bet is to check out the contributing guide in the docs!","title":"Contributing"},{"location":"index.html#credits","text":"This package was created with cookiecutter and the FollowTheProcess/cookie_pypackage project template.","title":"Credits"},{"location":"api/version.html","text":"The Version object \u00b6 __init__ ( self , major , minor , patch , prerelease = None , buildmetadata = None ) special \u00b6 A data container for a semantic version. Parameters: Name Type Description Default major int The major version, to be incremented when making backwards incompatible (breaking) changes. required minor int The minor version, to be incremented when introducing backwards compatible features. required patch int The patch version, to be incremented when making backwards compatible bug fixes. required prerelease Optional[str] Any pre-release tags e.g. 'rc.1'. Defaults to None. None buildmetadata Optional[str] Any build meta tags e.g. 'build.123'. Defaults to None. None Exceptions: Type Description ValueError If any numeric version part < 0. Source code in madonna/version.py def __init__ ( self , major : int , minor : int , patch : int , prerelease : str | None = None , buildmetadata : str | None = None , ) -> None : \"\"\" A data container for a semantic version. Args: major (int): The major version, to be incremented when making backwards incompatible (breaking) changes. minor (int): The minor version, to be incremented when introducing backwards compatible features. patch (int): The patch version, to be incremented when making backwards compatible bug fixes. prerelease (Optional[str], optional): Any pre-release tags e.g. 'rc.1'. Defaults to None. buildmetadata (Optional[str], optional): Any build meta tags e.g. 'build.123'. Defaults to None. Raises: ValueError: If any numeric version part < 0. \"\"\" self . major = major self . minor = minor self . patch = patch self . prerelease = prerelease self . buildmetadata = buildmetadata if any ( part < 0 for part in ( self . major , self . minor , self . patch )): raise ValueError ( f \"Version { self !r} is invalid. Parts cannot be less than 0.\" ) bump_major ( self ) \u00b6 Return a new Version with the major version number bumped. Returns: Type Description Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_major () Version ( major = 2 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py def bump_major ( self ) -> Version : \"\"\" Return a new `Version` with the major version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_major() Version(major=2, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major + 1 , 0 , 0 ) bump_minor ( self ) \u00b6 Return a new Version with the minor version number bumped. Returns: Type Description Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_minor () Version ( major = 1 , minor = 3 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py def bump_minor ( self ) -> Version : \"\"\" Return a new `Version` with the minor version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_minor() Version(major=1, minor=3, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor + 1 , 0 ) bump_patch ( self ) \u00b6 Return a new Version with the patch version number bumped. Returns: Type Description Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_patch () Version ( major = 1 , minor = 2 , patch = 5 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py def bump_patch ( self ) -> Version : \"\"\" Return a new `Version` with the patch version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_patch() Version(major=1, minor=2, patch=5, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor , self . patch + 1 ) from_dict ( version_dict ) classmethod \u00b6 Construct and return a Version from a dictionary of it's parts. Expects a dictionary with keys: major , minor , patch , prerelease and buildmetadata . Parameters: Name Type Description Default version_dict VersionDict Version as a dictionary of it's parts. required Returns: Type Description Version Constructed Version. Exceptions: Type Description TypeError If the passed dictionary does not have keys matching the required parts. Examples: >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 , \"prerelease\" : \"rc.1\" , \"buildmetadata\" : \"build.123\" } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_dict ( cls , version_dict : VersionDict ) -> Version : \"\"\" Construct and return a `Version` from a dictionary of it's parts. Expects a dictionary with keys: `major`, `minor`, `patch`, `prerelease` and `buildmetadata`. Args: version_dict (VersionDict): Version as a dictionary of it's parts. Returns: Version: Constructed Version. Raises: TypeError: If the passed dictionary does not have keys matching the required parts. Examples: ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( ** version_dict ) from_json ( json_string ) classmethod \u00b6 Construct and return a Version from a json string of it's parts. Parameters: Name Type Description Default json_string str The json string. required Returns: Type Description Version The constructed Version. Examples: >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_json ( cls , json_string : str ) -> Version : \"\"\" Construct and return a `Version` from a json string of it's parts. Args: json_string (str): The json string. Returns: Version: The constructed Version. Examples: ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" data : VersionDict = json . loads ( json_string ) return Version ( ** data ) from_string ( string ) classmethod \u00b6 Construct and return a Version from a valid semver string. Parameters: Name Type Description Default string str The semver string. required Exceptions: Type Description ValueError If the semver string does not pass the official semver regex. Returns: Type Description Version The constructed Version. Examples: >>> Version . from_string ( \"v1.2.4\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> Version . from_string ( \"v1.2.4-rc.1+build.123\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_string ( cls , string : str ) -> Version : \"\"\" Construct and return a `Version` from a valid semver string. Args: string (str): The semver string. Raises: ValueError: If the semver string does not pass the official semver regex. Returns: Version: The constructed Version. Examples: ```python >>> Version.from_string(\"v1.2.4\") Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> Version.from_string(\"v1.2.4-rc.1+build.123\") Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" match = _SEMVER_REGEX . match ( string ) if not match : raise ValueError ( f \" { string !r} is not a valid semver string.\" ) return Version . from_dict ( VersionDict ( major = int ( match . group ( \"major\" )), minor = int ( match . group ( \"minor\" )), patch = int ( match . group ( \"patch\" )), prerelease = match . group ( \"prerelease\" ), buildmetadata = match . group ( \"buildmetadata\" ), ) ) from_tuple ( tup ) classmethod \u00b6 Construct and return a Version from a tuple of it's parts. Parameters: Name Type Description Default tup VersionTuple The tuple to construct the Version from. required Returns: Type Description Version The constructed Version. Examples: >>> v = ( 1 , 2 , 4 ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = ( 1 , 2 , 4 , \"rc.1\" , \"build.123\" ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_tuple ( cls , tup : VersionTuple ) -> Version : \"\"\" Construct and return a `Version` from a tuple of it's parts. Args: tup (VersionTuple): The tuple to construct the Version from. Returns: Version: The constructed Version. Examples: ```python >>> v = (1, 2, 4) >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = (1, 2, 4, \"rc.1\", \"build.123\") >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( * tup ) is_valid ( self ) \u00b6 Checks the Version against the official semver regex pattern and reports whether or not it is a valid semver. Returns: Type Description bool True if Version is valid, else False Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . is_valid () True >>> v = Version ( 1 , 2 , 4 , \"blah198y_+-2-\" , \"build---19790\" ) >>> v . is_valid () False Source code in madonna/version.py def is_valid ( self ) -> bool : \"\"\" Checks the `Version` against the official semver regex pattern and reports whether or not it is a valid semver. Returns: bool: True if `Version` is valid, else False Examples: ```python >>> v = Version(1, 2, 4) >>> v.is_valid() True ``` ```python >>> v = Version(1, 2, 4, \"blah198y_+-2-\", \"build---19790\") >>> v.is_valid() False ``` \"\"\" return bool ( _SEMVER_REGEX . match ( self . to_string ())) to_dict ( self ) \u00b6 Return the Version as a dictionary. Returns: Type Description VersionDict The Version dictionary. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : None , 'buildmetadata' : None } >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : 'rc.1' , 'buildmetadata' : 'build.2' } Source code in madonna/version.py def to_dict ( self ) -> VersionDict : \"\"\" Return the `Version` as a dictionary. Returns: VersionDict: The Version dictionary. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': None, 'buildmetadata': None} ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': 'rc.1', 'buildmetadata': 'build.2'} ``` \"\"\" return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"buildmetadata\" : self . buildmetadata , } to_json ( self ) \u00b6 Return the Version as a JSON string. Returns: Type Description str The Version JSON string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' Source code in madonna/version.py def to_json ( self ) -> str : \"\"\" Return the `Version` as a JSON string. Returns: str: The Version JSON string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' ``` \"\"\" return json . dumps ( self . to_dict ()) to_string ( self ) \u00b6 Generate a string representation of the Version . Returns: Type Description str Version string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_string () 'v1.2.4' >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_string () 'v1.2.4-rc.2+build.6' Source code in madonna/version.py def to_string ( self ) -> str : \"\"\" Generate a string representation of the `Version`. Returns: str: Version string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_string() 'v1.2.4' ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_string() 'v1.2.4-rc.2+build.6' ``` \"\"\" return str ( self ) to_tuple ( self ) \u00b6 Return the Version as a tuple of it's fields. Returns: Type Description VersionTuple The Version tuple. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_tuple () ( 1 , 2 , 4 , None , None ) >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_tuple () ( 1 , 2 , 4 , 'rc.2' , 'build.6' ) Source code in madonna/version.py def to_tuple ( self ) -> VersionTuple : \"\"\" Return the `Version` as a tuple of it's fields. Returns: VersionTuple: The Version tuple. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_tuple() (1, 2, 4, None, None) ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_tuple() (1, 2, 4, 'rc.2', 'build.6') ``` \"\"\" return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata )","title":"Version"},{"location":"api/version.html#the-version-object","text":"","title":"The Version object"},{"location":"api/version.html#madonna.version.Version.__init__","text":"A data container for a semantic version. Parameters: Name Type Description Default major int The major version, to be incremented when making backwards incompatible (breaking) changes. required minor int The minor version, to be incremented when introducing backwards compatible features. required patch int The patch version, to be incremented when making backwards compatible bug fixes. required prerelease Optional[str] Any pre-release tags e.g. 'rc.1'. Defaults to None. None buildmetadata Optional[str] Any build meta tags e.g. 'build.123'. Defaults to None. None Exceptions: Type Description ValueError If any numeric version part < 0. Source code in madonna/version.py def __init__ ( self , major : int , minor : int , patch : int , prerelease : str | None = None , buildmetadata : str | None = None , ) -> None : \"\"\" A data container for a semantic version. Args: major (int): The major version, to be incremented when making backwards incompatible (breaking) changes. minor (int): The minor version, to be incremented when introducing backwards compatible features. patch (int): The patch version, to be incremented when making backwards compatible bug fixes. prerelease (Optional[str], optional): Any pre-release tags e.g. 'rc.1'. Defaults to None. buildmetadata (Optional[str], optional): Any build meta tags e.g. 'build.123'. Defaults to None. Raises: ValueError: If any numeric version part < 0. \"\"\" self . major = major self . minor = minor self . patch = patch self . prerelease = prerelease self . buildmetadata = buildmetadata if any ( part < 0 for part in ( self . major , self . minor , self . patch )): raise ValueError ( f \"Version { self !r} is invalid. Parts cannot be less than 0.\" )","title":"__init__()"},{"location":"api/version.html#madonna.version.Version.bump_major","text":"Return a new Version with the major version number bumped. Returns: Type Description Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_major () Version ( major = 2 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py def bump_major ( self ) -> Version : \"\"\" Return a new `Version` with the major version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_major() Version(major=2, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major + 1 , 0 , 0 )","title":"bump_major()"},{"location":"api/version.html#madonna.version.Version.bump_minor","text":"Return a new Version with the minor version number bumped. Returns: Type Description Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_minor () Version ( major = 1 , minor = 3 , patch = 0 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py def bump_minor ( self ) -> Version : \"\"\" Return a new `Version` with the minor version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_minor() Version(major=1, minor=3, patch=0, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor + 1 , 0 )","title":"bump_minor()"},{"location":"api/version.html#madonna.version.Version.bump_patch","text":"Return a new Version with the patch version number bumped. Returns: Type Description Version New bumped version. Examples: >>> v1 = Version ( 1 , 2 , 4 ) >>> v1 . bump_patch () Version ( major = 1 , minor = 2 , patch = 5 , prerelease = None , buildmetadata = None ) >>> v1 = Version ( 0 , 7 , 6 , \"rc.1\" , \"build.123\" ) >>> v1 . bump_major () Version ( major = 1 , minor = 0 , patch = 0 , prerelease = None , buildmetadata = None ) Source code in madonna/version.py def bump_patch ( self ) -> Version : \"\"\" Return a new `Version` with the patch version number bumped. Returns: Version: New bumped version. Examples: ```python >>> v1 = Version(1, 2, 4) >>> v1.bump_patch() Version(major=1, minor=2, patch=5, prerelease=None, buildmetadata=None) ``` ```python >>> v1 = Version(0, 7, 6, \"rc.1\", \"build.123\") >>> v1.bump_major() Version(major=1, minor=0, patch=0, prerelease=None, buildmetadata=None) ``` \"\"\" return Version ( self . major , self . minor , self . patch + 1 )","title":"bump_patch()"},{"location":"api/version.html#madonna.version.Version.from_dict","text":"Construct and return a Version from a dictionary of it's parts. Expects a dictionary with keys: major , minor , patch , prerelease and buildmetadata . Parameters: Name Type Description Default version_dict VersionDict Version as a dictionary of it's parts. required Returns: Type Description Version Constructed Version. Exceptions: Type Description TypeError If the passed dictionary does not have keys matching the required parts. Examples: >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = { \"major\" : 1 , \"minor\" : 2 , \"patch\" : 4 , \"prerelease\" : \"rc.1\" , \"buildmetadata\" : \"build.123\" } >>> Version . from_dict ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_dict ( cls , version_dict : VersionDict ) -> Version : \"\"\" Construct and return a `Version` from a dictionary of it's parts. Expects a dictionary with keys: `major`, `minor`, `patch`, `prerelease` and `buildmetadata`. Args: version_dict (VersionDict): Version as a dictionary of it's parts. Returns: Version: Constructed Version. Raises: TypeError: If the passed dictionary does not have keys matching the required parts. Examples: ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = {\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"} >>> Version.from_dict(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( ** version_dict )","title":"from_dict()"},{"location":"api/version.html#madonna.version.Version.from_json","text":"Construct and return a Version from a json string of it's parts. Parameters: Name Type Description Default json_string str The json string. required Returns: Type Description Version The constructed Version. Examples: >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version . from_json ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_json ( cls , json_string : str ) -> Version : \"\"\" Construct and return a `Version` from a json string of it's parts. Args: json_string (str): The json string. Returns: Version: The constructed Version. Examples: ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.123\"}' >>> Version.from_json(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" data : VersionDict = json . loads ( json_string ) return Version ( ** data )","title":"from_json()"},{"location":"api/version.html#madonna.version.Version.from_string","text":"Construct and return a Version from a valid semver string. Parameters: Name Type Description Default string str The semver string. required Exceptions: Type Description ValueError If the semver string does not pass the official semver regex. Returns: Type Description Version The constructed Version. Examples: >>> Version . from_string ( \"v1.2.4\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> Version . from_string ( \"v1.2.4-rc.1+build.123\" ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_string ( cls , string : str ) -> Version : \"\"\" Construct and return a `Version` from a valid semver string. Args: string (str): The semver string. Raises: ValueError: If the semver string does not pass the official semver regex. Returns: Version: The constructed Version. Examples: ```python >>> Version.from_string(\"v1.2.4\") Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> Version.from_string(\"v1.2.4-rc.1+build.123\") Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" match = _SEMVER_REGEX . match ( string ) if not match : raise ValueError ( f \" { string !r} is not a valid semver string.\" ) return Version . from_dict ( VersionDict ( major = int ( match . group ( \"major\" )), minor = int ( match . group ( \"minor\" )), patch = int ( match . group ( \"patch\" )), prerelease = match . group ( \"prerelease\" ), buildmetadata = match . group ( \"buildmetadata\" ), ) )","title":"from_string()"},{"location":"api/version.html#madonna.version.Version.from_tuple","text":"Construct and return a Version from a tuple of it's parts. Parameters: Name Type Description Default tup VersionTuple The tuple to construct the Version from. required Returns: Type Description Version The constructed Version. Examples: >>> v = ( 1 , 2 , 4 ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = None , buildmetadata = None ) >>> v = ( 1 , 2 , 4 , \"rc.1\" , \"build.123\" ) >>> Version . from_tuple ( v ) Version ( major = 1 , minor = 2 , patch = 4 , prerelease = 'rc.1' , buildmetadata = 'build.123' ) Source code in madonna/version.py @classmethod def from_tuple ( cls , tup : VersionTuple ) -> Version : \"\"\" Construct and return a `Version` from a tuple of it's parts. Args: tup (VersionTuple): The tuple to construct the Version from. Returns: Version: The constructed Version. Examples: ```python >>> v = (1, 2, 4) >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease=None, buildmetadata=None) ``` ```python >>> v = (1, 2, 4, \"rc.1\", \"build.123\") >>> Version.from_tuple(v) Version(major=1, minor=2, patch=4, prerelease='rc.1', buildmetadata='build.123') ``` \"\"\" return Version ( * tup )","title":"from_tuple()"},{"location":"api/version.html#madonna.version.Version.is_valid","text":"Checks the Version against the official semver regex pattern and reports whether or not it is a valid semver. Returns: Type Description bool True if Version is valid, else False Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . is_valid () True >>> v = Version ( 1 , 2 , 4 , \"blah198y_+-2-\" , \"build---19790\" ) >>> v . is_valid () False Source code in madonna/version.py def is_valid ( self ) -> bool : \"\"\" Checks the `Version` against the official semver regex pattern and reports whether or not it is a valid semver. Returns: bool: True if `Version` is valid, else False Examples: ```python >>> v = Version(1, 2, 4) >>> v.is_valid() True ``` ```python >>> v = Version(1, 2, 4, \"blah198y_+-2-\", \"build---19790\") >>> v.is_valid() False ``` \"\"\" return bool ( _SEMVER_REGEX . match ( self . to_string ()))","title":"is_valid()"},{"location":"api/version.html#madonna.version.Version.to_dict","text":"Return the Version as a dictionary. Returns: Type Description VersionDict The Version dictionary. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : None , 'buildmetadata' : None } >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_dict () { 'major' : 1 , 'minor' : 2 , 'patch' : 4 , 'prerelease' : 'rc.1' , 'buildmetadata' : 'build.2' } Source code in madonna/version.py def to_dict ( self ) -> VersionDict : \"\"\" Return the `Version` as a dictionary. Returns: VersionDict: The Version dictionary. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': None, 'buildmetadata': None} ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_dict() {'major': 1, 'minor': 2, 'patch': 4, 'prerelease': 'rc.1', 'buildmetadata': 'build.2'} ``` \"\"\" return { \"major\" : self . major , \"minor\" : self . minor , \"patch\" : self . patch , \"prerelease\" : self . prerelease , \"buildmetadata\" : self . buildmetadata , }","title":"to_dict()"},{"location":"api/version.html#madonna.version.Version.to_json","text":"Return the Version as a JSON string. Returns: Type Description str The Version JSON string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' >>> v = Version ( 1 , 2 , 4 , \"rc.1\" , \"build.2\" ) >>> v . to_json () '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' Source code in madonna/version.py def to_json ( self ) -> str : \"\"\" Return the `Version` as a JSON string. Returns: str: The Version JSON string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": null, \"buildmetadata\": null}' ``` ```python >>> v = Version(1, 2, 4, \"rc.1\", \"build.2\") >>> v.to_json() '{\"major\": 1, \"minor\": 2, \"patch\": 4, \"prerelease\": \"rc.1\", \"buildmetadata\": \"build.2\"}' ``` \"\"\" return json . dumps ( self . to_dict ())","title":"to_json()"},{"location":"api/version.html#madonna.version.Version.to_string","text":"Generate a string representation of the Version . Returns: Type Description str Version string. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_string () 'v1.2.4' >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_string () 'v1.2.4-rc.2+build.6' Source code in madonna/version.py def to_string ( self ) -> str : \"\"\" Generate a string representation of the `Version`. Returns: str: Version string. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_string() 'v1.2.4' ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_string() 'v1.2.4-rc.2+build.6' ``` \"\"\" return str ( self )","title":"to_string()"},{"location":"api/version.html#madonna.version.Version.to_tuple","text":"Return the Version as a tuple of it's fields. Returns: Type Description VersionTuple The Version tuple. Examples: >>> v = Version ( 1 , 2 , 4 ) >>> v . to_tuple () ( 1 , 2 , 4 , None , None ) >>> v = Version ( 1 , 2 , 4 , \"rc.2\" , \"build.6\" ) >>> v . to_tuple () ( 1 , 2 , 4 , 'rc.2' , 'build.6' ) Source code in madonna/version.py def to_tuple ( self ) -> VersionTuple : \"\"\" Return the `Version` as a tuple of it's fields. Returns: VersionTuple: The Version tuple. Examples: ```python >>> v = Version(1, 2, 4) >>> v.to_tuple() (1, 2, 4, None, None) ``` ```python >>> v = Version(1, 2, 4, \"rc.2\", \"build.6\") >>> v.to_tuple() (1, 2, 4, 'rc.2', 'build.6') ``` \"\"\" return ( self . major , self . minor , self . patch , self . prerelease , self . buildmetadata )","title":"to_tuple()"},{"location":"contributing/code_of_conduct.html","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"contributing/code_of_conduct.html#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"contributing/code_of_conduct.html#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"contributing/code_of_conduct.html#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"contributing/code_of_conduct.html#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"contributing/code_of_conduct.html#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"contributing/code_of_conduct.html#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"contributing/code_of_conduct.html#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"contributing/contributing.html","text":"Contributing to madonna \u00b6 I've tried to structure madonna to make it nice and easy for people to contribute. Here's how to go about doing it! Note All contributors must follow the Code of Conduct Developing \u00b6 If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to madonna: here's how you do it! To work on madonna you'll need python >=3.8 Step 1: Fork madonna \u00b6 The first thing to do is 'fork' madonna. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of madonna still works! To create a fork, go to the madonna repo and click on the fork button! Step 2: Clone your fork \u00b6 Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/madonna.git If you use SSH: git clone git@github.com:<your_github_username>/madonna.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/madonna HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd madonna This will take you into the root directory of the project. Now add the original madonna repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/madonna.git This makes the original version of madonna upstream but not origin . Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Note Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower! Step 3: Create the Environment \u00b6 Before you do anything, you'll want to set up your development environment... madonna uses poetry to manage development and nox for automation superpowers. So to work on it you'll need to get both of those tools too! I recommend using pipx for python command line tools like these, it installs each tool in it's own isolated environment but exposes the command to your terminal as if you installed it globally. We've automated the crap out of the development process for madonna, to get started all you need to do is run: nox Note If you've never used nox before, go check it out. It's great! It's an amazing project automation toolkit, you can do just about anything with it but it's especially good at things like this! When you run this, nox will: Create a fresh python virtual environment in the project for you (.venv) Install madonna for you along with all of it's development dependencies Make sure VSCode is set up to use this environment (if you use it) Not bad for a single command! Doing it this way means that before you start working on madonna you know its all been installed and works correctly. Wait for it to do it's thing and then you can get started. Note The next time you run nox , it won't do this step again. It will run all the project tests, lint and format the source code, analyse test coverage and build the docs Step 4: Do your thing \u00b6 Always checkout a new branch before changing anything git checkout -b <name-of-your-bugfix-or-feature> Now you're ready to start working! Remember! madonna aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! madonna uses nox for automated testing, building the docs, formatting and linting etc. So when you've made your changes, just run: nox And it will tell you if something's wrong! Step 5: Commit your changes \u00b6 Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name> Step 6: Create a Pull Request \u00b6 Now go to the original madonna repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. That's it! Your code will be tested automatically by madonna's CI suite and if everything passes and your PR is approved and merged then it will become part of madonna! Note: There is a good guide to open source contribution workflow here and also here too Contributing to Docs \u00b6 Any improvements to the documentation are always appreciated! madonna uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Because madonna uses nox , things like building and serving the documentation is super easy. All you have to do is: # Builds the docs nox -s docs # Builds and serves to localhost nox -s docs -- serve If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Guide"},{"location":"contributing/contributing.html#contributing-to-madonna","text":"I've tried to structure madonna to make it nice and easy for people to contribute. Here's how to go about doing it! Note All contributors must follow the Code of Conduct","title":"Contributing to madonna"},{"location":"contributing/contributing.html#developing","text":"If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to madonna: here's how you do it! To work on madonna you'll need python >=3.8","title":"Developing"},{"location":"contributing/contributing.html#step-1-fork-madonna","text":"The first thing to do is 'fork' madonna. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of madonna still works! To create a fork, go to the madonna repo and click on the fork button!","title":"Step 1: Fork madonna"},{"location":"contributing/contributing.html#step-2-clone-your-fork","text":"Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/madonna.git If you use SSH: git clone git@github.com:<your_github_username>/madonna.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/madonna HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd madonna This will take you into the root directory of the project. Now add the original madonna repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/madonna.git This makes the original version of madonna upstream but not origin . Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Note Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower!","title":"Step 2: Clone your fork"},{"location":"contributing/contributing.html#step-3-create-the-environment","text":"Before you do anything, you'll want to set up your development environment... madonna uses poetry to manage development and nox for automation superpowers. So to work on it you'll need to get both of those tools too! I recommend using pipx for python command line tools like these, it installs each tool in it's own isolated environment but exposes the command to your terminal as if you installed it globally. We've automated the crap out of the development process for madonna, to get started all you need to do is run: nox Note If you've never used nox before, go check it out. It's great! It's an amazing project automation toolkit, you can do just about anything with it but it's especially good at things like this! When you run this, nox will: Create a fresh python virtual environment in the project for you (.venv) Install madonna for you along with all of it's development dependencies Make sure VSCode is set up to use this environment (if you use it) Not bad for a single command! Doing it this way means that before you start working on madonna you know its all been installed and works correctly. Wait for it to do it's thing and then you can get started. Note The next time you run nox , it won't do this step again. It will run all the project tests, lint and format the source code, analyse test coverage and build the docs","title":"Step 3: Create the Environment"},{"location":"contributing/contributing.html#step-4-do-your-thing","text":"Always checkout a new branch before changing anything git checkout -b <name-of-your-bugfix-or-feature> Now you're ready to start working! Remember! madonna aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! madonna uses nox for automated testing, building the docs, formatting and linting etc. So when you've made your changes, just run: nox And it will tell you if something's wrong!","title":"Step 4: Do your thing"},{"location":"contributing/contributing.html#step-5-commit-your-changes","text":"Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name>","title":"Step 5: Commit your changes"},{"location":"contributing/contributing.html#step-6-create-a-pull-request","text":"Now go to the original madonna repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. That's it! Your code will be tested automatically by madonna's CI suite and if everything passes and your PR is approved and merged then it will become part of madonna! Note: There is a good guide to open source contribution workflow here and also here too","title":"Step 6: Create a Pull Request"},{"location":"contributing/contributing.html#contributing-to-docs","text":"Any improvements to the documentation are always appreciated! madonna uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Because madonna uses nox , things like building and serving the documentation is super easy. All you have to do is: # Builds the docs nox -s docs # Builds and serves to localhost nox -s docs -- serve If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Contributing to Docs"}]}